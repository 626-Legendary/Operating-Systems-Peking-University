# 操作系统运行环境（Lecture 2 笔记）

1. 处理器状态
大家好，今天我给大家带来的是操作系统原理的第二讲。 操作系统运行环境与运行机制。 那这一部分的内容是非常重要的。 为什么呢？我们先来回顾一下操作系统的主要工作。 操作系统支持程序的执行， 包括了启动程序、 执行程序以及程序结束后的一些工作。 操作系统还完成与体系结构相关的工作。 
完成与应用程序所需的共性任务。 还包括了性能、 安全、 健壮等问题。 那么在这里头操作系统完成与体系结构相关的工作， 这是一个非常重要的点。 这是操作系统与其他软件所不同的地方。 设计操作系统的时候必须和硬件打交道， 必须了解硬件体系结构。 除此之外 操作系统还完成应用程序所需的共性任务。 在应用程序运行过程中需要做很多的工作。 
比如说读盘、 申请一块内存存放数据、 用打印机来打印文件。 那么这些工作呢， 是操作系统完成的，并且呢向用户提供这些基本服务。 所以我们通过这张图的回顾， 来明确一下操作系统的地位。 操作系统 是在硬件基础上的第一层扩展。 那么它底下是硬件， 那么这个硬件都做了什么工作呢？ 我们怎么样去了解底下的硬件呢？那么这就是我们 本讲的一个内容之一：操作系统运行环境。 
那么和硬件相关的很多的 工作呢实际上是和操作系统的各个功能 相结合的，那么我们这里头呢只介绍最基本的 CPU 状态： 中断与异常机制。 其他的像虚拟页式存储管理的机制， 设备等等的，那么我们放到后面跟操作系统功能结合起来讲。 操作系统完成应用程序当中的一些共性的工作， 向应用程序提供一些基本服务，那么这是我们本讲的另外一方面的内容 操作系统运行机制，我们重点介绍系统调用机制。 那么我们首先介绍 处理器的状态，有的时候也叫处理器模式。 CPU 是由运算器 控制器、 一系列的寄存器以及高速缓存 构成。 那我们来看一看有两类寄存器。 一类是用户可见寄存器，那么高级语言 编译器通过优化算法分配这些寄存器，并且使用这些寄存器 主要的目的是为了减少访问内存的次数， 来提高程序的运行效率。 
作为操作系统设计者，我们更加关注的是 控制和状态寄存器。 那么这些寄存器呢是用于 控制处理器的操作，那么通常呢是只能由操作系统代码来使用。 我们来看一下控制和状态寄存器。 它用于控制处理器的操作， 在某些特权级别下可以访问来修改。 典型的控制和状态寄存器呢包括了程序计数器 PC，那么这里头记录了要取出的指令的地址。 指令寄存器记录了最近取出的指令。 程序状态字寄存器 PSW，它记录了 CPU 的运行状态， 一些条件码、 模式、 控制位等信息。 
下面我们来探讨一下操作系统 对硬件的需求，其中一个非常重要的需求就是保护。 因为操作系统运行在一个 多进程的这样一个环境下，支持这些进程的运行。 因此我们从操作系统的特征来考虑: 并发、 共享。 操作系统为多个程序的执行提供了这样一个 并发的环境，那么多个进程之间呢又共享操作系统所管理的各种资源。 那么这样一个并发、 共享的计算环境就要求保护 保护是保护用户程序与用户程序之间 互不干扰，保护是保护用户程序不对操作系统干扰。 那么这就从操作系统的角度给硬件提出了一个需求。 要实现保护、 实现保护控制。 
通常，我们对硬件希望提供这样的一个 基本运行机制。 也就是 CPU 呢它具有一个特权级别， 在不同的特权级下可以运行不同的指令集合。 这样把指令分成不同的集合，那么供 操作系统和用户程序分别使用。 那么通过保护呢又使得 操作系统与用户能够相隔离，能够相隔离。 比如说当要访问操作系统空间的时候，那么用户程序是不能够访问的。 那么操作系统可以访问用户程序空间， 因此达到了，通过一个保护机制能够达到操作系统与用户的隔离。 有了这样一个需求之后， 现代处理器通常把 CPU 的状态 设计为两种、 三种、 或者是四种。 
那么在 CPU 上 时而运行操作系统、 时而运行用户程序， 那么 CPU 如何知道是运行哪一种状态呢？ 这样就有赖于一些寄存器的某些位的设置。 通常呢是在程序状态字寄存器 PSW 当中呢来专门设置一位，有的时候是两位 根据运行程序对资源和指令的权限不同， 来设置不同的 CPU 状态。 好，那么 不同的程序对资源和指令的使用要求是不同的， 我们来看一下 X86 处理器当中的 典型的一个标志寄存器 EFLAGS，EFLAGS 寄存器。 那么这里头呢就有一位 IO PL 是 IO 的权限位，IO 的权限级别。 那么这个级别呢我们可以看到用两位来表示 两位可以表示四个状态，四个状态。 除了这个寄存器以外，还有一些 描述符也规定了，设置了权限级别。 
这是硬件提供的各种不同的 CPU 状态 那么操作系统呢其实需要两种 CPU 状态 一种是用于内核态：运行操作系统的代码 另一种呢是用户态：运行用户程序。 所以呢，操作系统只需要两个状态 那么两个状态呢可以指向不同的指令集合 因此我们把指令的集合划分成 两类，一类呢我们称之为特权指令， 所谓特权指令呢是只能够由操作系统来使用 那么用户呢是不能使用的指令 那么另外一类呢就叫非特权指令 是用户可以使用的指令，其实整个指令系统呢，那么操作系统是都可以使用的 它既可以使用特权指令，也可以使用非特权指令 而用户呢只能使用这个指令 系统当中的一个子集，那么这个子集就是非特权指令 那么下面呢提个问题，下列哪些指令 是特权指令，哪些指令呢是非特权指令？ 比如说启动 I/O 那么各种各样的输入/输出设备由操作系统管理 用户程序如果需要打印，如果要扫描，那么它自己不能完成这些工作 它必须把这个请求提交给操作系统，由操作系统代它来完成这些任务 所以启动 I/O 这个指令是特权指令 那么程序执行过程中有很多的控制转移，那么这就是非特权指令 那如果对内存 设置清零，那么这个呢只能够由操作系统来做 那么用户呢只能在操作系统的授权下来完成这项事情，所以 内存清零是由，是特权指令 修改程序状态字，那显然是一个特权指令 只能操作系统来设置 CPU 的状态，做一些其他方面的设置 所以这是一个典型的特权指令。 设置时钟 是特权指令，算术运算当然是非特权指令 如果我不想接收中断 或者是我想接收中断，做这样的设置，那么也是特权指令 停机是特权指令 取数指令呢是非特权指令。 那么这里有一个非常特殊的指令 我们叫做访管指令。 那么这条指令呢 我们后面会专门来介绍。 这条指令呢是非特权指令 但是它的作用呢，是使得用户程序从用户态陷入操作系统内核态 那我们来举一个例子 X86 系列处理器，它提供了四个 特权级别。 
我们把它称之为特权环 R0， R1， R2 和 R3 那么从 R0 到 R3 它的特权的能力是由高到底的。 那么硬件设计者 设计了这样不同的特权级别 主要的目的呢，是希望在不同的级别呢能够运行不同的 程序。 比如说 R0 是希望能运行操作系统的一些关键代码 所以 R0 相当于内核态。 R1 呢 是运行设备驱动程序和一些 I/O 处理的历程 R2 呢，是运行一些受保护 共享的代码，比如说一些语言编译环境 而 R0 呢，R3 呢是给 用户程序使用的。 那么 R3 呢就相当于用户态 而 R1 和 R2 呢实际上是介乎于两者之间 那么不同的这种特权级别 其实就是运行指令的集合是不一样的 我们来看一下 R0 实际上是运行了所有的指令 而 R3 是运行的一个最小的子集 那么当然了，我们刚才说了，操作系统需要两个状态 所以呢通常情况下，大部分的 操作系统我们所熟知的，Linux 啊，Windows 啊，Unix 啊 都是只选择了 R0 和 R3 这两个特权级别 来使用。 那么有了不同的 特权级别，那么就需要 让用户程序和操作系统之间能有转换 那么实际上呢用户程序在执行的过程中 如果需要操作系统的服务，它就要从用户态能够陷入到，进入内核态 而从用户态进入内核态的一个唯一的途径 唯一的通路实际上就是中断/异常/陷入机制 这也是我们下一个非常重要的主题 那么从内核态返回到用户态呢？ 则比较简单啊，只是通过设置程序状态字寄存器就可以了 那么我们刚才说的一条特殊的指令 陷入指令，或者呢叫访管指令 那么这条指令呢，它的作用呢是提供给用户程序的一个接口 用这个接口使用户程序可以向操作系统提出各种服务请求 那么为什么叫访管指令呢？ 因为有的时候内核态也被称为一个 supervisor mode 管理态。 
所以在这种情况下呢，那么从用户态进入了管理态，相当于访问管理态 所以叫访管指令，有这样一个说法。 所以大家记忆的时候呢说访管指令是因为有这样一个 对内核态的另外一种称呼，所以有这一个访管指令 那么这条特殊的指令在不同的计算机系统当中呢 实际上是用不同的指令的。 比如说我们看到了有 int 指令 有 trap 指令，syscall 还有 我们就叫 sysenter/sysexit。 那么这些指令都是 不同的计算机体系结构提供的这种 特殊的指令，用于陷入，用于访管 所以这是关于 CPU 状态之间的转换需要的不同的条件 

2.中断与异常机制介绍

下面我们介绍中断与异常机制 那么这个机制是操作系统的一个 驱动力，非常重要。 操作系统当中 中断和异常机制就好比是汽车中的发动机，或者是飞机引擎 靠它来驱动操作系统的运行。 我们 有的时候是可以这么说的，操作系统是由中断驱动的 当然了也可以说是由事件驱动的。 那么有了这个机制 操作系统就可以做很多的事情，比如说 操作系统就可以及时地来处理各种各样的外部设备 发来的一些请求。 也可以使得操作系统 可以及时地捕获到了用户程序提出的各种服务 同时，有了这个机制还可以防止用户 在执行过程中有意识或者是无意识的一些破坏性的活动 等等，所以有了这样一个机制，操作系统就可以做更多的事情 我们来介绍一下中断与异常的概念 所谓中断与异常，实际上是 CPU 对系统发生的某个事件的一种反应 当这个事件发生的时候 通过对这个事件的处理 实际上是改变了一个控制流 我们通常说事件的发生改变了 CPU 的一个控制流 那么怎么改变呢？我们来看一下。 发生了事件之后 CPU 会暂停正在执行的程序 保留现场。 
然后呢 自动去处理，去执行对这个事件的处理程序 完成了这个处理过程之后，返回到断点 继续执行刚才被打断的程序。 这是一个对 中断和异常这样一个事件发生之后 如何改变控制流的一个描述 从这个描述当中呢，其实我们会看到了 有几个重要的特点。 一个特点呢 是中断或异常这个事件呢是随机发生的 我们在何处发生？什么时候发生？ 事先呢是不能判断的。 第二呢 中断和异常的这个处理呢是一个自动处理的过程 所谓自动处理的过程呢我们是想强调这个过程是由硬件来完成的 硬件自动地完成整个控制流的转移工作 第三个特点呢是 中断和异常事件发生之后呢是可恢复的 所谓可恢复呢就指的是被打断的 这个事件完了之后被打断的这个程序可以在以后某个时刻呢再接着执行 所以这是对中断和异常的一个初步的介绍 那么我们通过历史的背景 来讲一下为什么引入中断与异常 首先，中断的引入 实际上是为了支持 CPU 与外部设备的一个并行操作这样一个能力 早期的计算机系统，如果没有中断机制的话 那么 CPU 要负责对设备的所有工作的管理 但是有了这样一个中断机制之后呢 我们就可以这样来工作了。 CPU 呢会去启动 输入输出设备的工作。 
启动做完了之后呢 设备本身就可以独立自己进行工作了 而 CPU 这个时候呢可以转去处理一些和这次输入输出没有关系的事情 那么当然，当设备完成了它的任务之后 它通过什么样的方式告诉 CPU 呢？ 实际上是通过了中断。 那么外部设备 去通过中断向 CPU 报告我这次输入输出的结果 让 CPU 来决策下面该做什么事情。 所以它是一种 向 CPU 发中断呢是一种向 CPU 汇报的手段 这是最早为什么引入中断机制，是为了让 CPU 和设备能够并行工作 但是设备完成工作之后呢要向 CPU 汇报，所以引入了中断 那么异常呢？异常呢主要是 表示 CPU 在执行过程中自身出现的一些问题 比如说在执行过程中出现了算术溢出 除零，或者是取数的时候呢奇偶交元错 也可能访问内存的时候呢地址越界 或者是刻意安排了一个特殊的陷入指令 那么这个时候硬件呢会改变 CPU 的当前的一个控制流程 然后去转去执行对错误的处理 对异常的处理或者是执行相应的系统服务 那么早期呢，是不区分 中断和异常的，都叫中断，我们其实都统称为中断 但是随着它们发生的原因不同，处理的一些 过程不同，那么就有了中断和异常的这么一个区分 但是我们在讲课的过程中 在讨论的过程中，有的时候 在不影响它的，这个对它的理解的情况下 我们可能就用中断来代表了中断和异常的各种事件 有的时候我们会这样，这是为了简化一些说法 那么这是关于中断和异常为什么引入 下面让我们放松一下，我们举一个日常 生活中的例子来体会一下中断和异常的一个区别 小明选了这门课 那么他呢要好好学习操作系统 那么他作为一个 CPU 呢正在看书，那么去 今天的内容呢是学习中断，今天要学习的内容是中断 这个时候呢在学习的过程中，大家看到 来电话了，电话铃响了，那么小明呢要先接个电话 然后呢再来看书。 那么这个时候他要 为了继续能够看书呢要在刚才被打断的地方呢要放个书签 然后呢他就去接电话去了 那么接电话呢就相当于我们说的中断的处理过程 当完成了这样接电话的任务处理之后呢 小明呢接着从刚才那个书签的地方接着来学习中断的知识 那么这就是中断。 我们再来看看异常 小明今天要学呢是异常的这个概念 那么他非常刻苦地学习，花了很长时间 结果呢学习这个异常 在学习过程中呢突然觉得口渴了 那么他决定先喝口水然后再来学 像刚才一样，他也要在 打断的地方放一个书签以便待会儿接着学习 那么喝水的过程，实际上就我们把它看成是一个异常处理的一个 执行过程。 
当他喝完水之后，接着回去 继续来学习异常的知识 通过这么一个日常生活中的例子呢我们可能会体会到中断和异常的不同点 下面我们来看看对中断和异常的具体的 事件的划分。 中断和异常实际上呢我们都把它可以叫做事件 那么中断呢，也可以称为外中断 异常呢我们一般叫内中断，这也是可以这么说的 我们来看看有哪些中断的事件呢？ 有 I/O 中断，输入输出中断，有时钟中断 还有硬件故障中断。 希望大家对 不同的中断类型呢能举出一两个例子 我们来看一下 I/O 中断 比如说，我们在键盘上按了 Ctrl + C 比如说网络上来了一个包，网卡接收到一个新的包，数据包 比如说打印机结束了 或者是读盘结束了 那么这样一些事件的发生，其实呢都是带来的是 I/O 中断 那么时钟中断呢，比如说我们设定了一个定时器 到点了，上，CPU 上运行的程序它的时间片到了，那么这些呢我们都 称之为时钟中断。 硬件故障中断呢我们可以举一个例子，比如说笔记本电脑 快没电了，这个电池快没了，快用完了 消耗完了，那这时候它要报警，提示你赶紧存盘或者是 充电。 那么这呢就属于硬件故障中断 读内存的时候呢，奇偶校验错呢也是一个比较典型的硬件故障中断 下面我们来看看有哪些具体的异常的事件 异常呢有很多 我们刚才说的一个典型的异常，系统调用其实是属于异常的 还有页故障或者叫页错误异常 那么我们在第一讲当中介绍 HelloWorld 程序执行过程中 第一条指令执行的时候产生了一个缺页异常，因为 要执行的代码在磁盘上还没有读入内存，那么这个时候 执行到这里的时候会，硬件会产生一个 叫做页故障，那我们具体的页故障就是缺页异常 保护性异常。 比如说一块内存空间 它呢标记成只读。 
当要做一个写的操作 这个就冲突了，操作和它的权限冲突了，所以这时候呢会引发一个保护性异常 如果要访问一个这个内存空间 那么访问的这个区域的地址越界了，那么也算保护性异常 还有就是断点指令，包括了我们说我们要调试程序，我们要设置 单步的调试，那么这样的话呢就要设置这样一个断点指令 你这样的话呢这就是一个异常。 当然还有很多的异常我们称之为程序性 异常。 程序性异常我们都比较常见，比如我们前面说的 算术溢出啊，除零啊，栈溢出等等都属于程序性异常 好，那么根据刚才那个日常中的例子和我们现在 举的例子我们可以归纳总结出来，所谓中断呢是外部事件 在 CPU 之外产生的事件打断了 CPU 那么这些事件呢是正在运行的程序所不期望的 异常呢是由正在执行的指令而引发的 这样我们可以区别一下中断和异常 那么我们最后呢 对中断和异常呢再做一个小结。 中断 实际上是来自各种各样的外部设备和一些硬件部件 那么它是个异步的事件。 在处理完中断之后 通常我们是返回到下一条指令 第一条指令执行完了，那么前一条指令执行完了 那么处理中断，返回到下一条指令执行 那么异常呢又分为三类 一类呢我们叫做陷入 一类叫做故障，一类叫做终止 那么陷入呢实际上是程序中刻意 安排的，有意识安排的，比如说我们安排的那条陷入指令 这是一条特殊的向操作系统提出请求的指令，那么这是刻意安排的 那么在处理完相关的事件之后呢是返回到下一条指令 如果在执行这条指令的时候呢发生了故障 那么这个时候这个故障又是可恢复的，那么 去做处理，最后返回到刚才发生故障的这条指令，返回到当前指令 那么如果发生了 一个事件，一个故障，这个故障呢是 不可恢复的，那我们把它称之为终止，也就是说 当发生这样的事件，那么就不会返回了 就退出了，因为出错了，而且是不可恢复的错 那么这张表呢把中断和异常做了一个很好的 小结 

3. 中断与 异常机制 工作原理

下面我们介绍一下中断/异常机制的工作原理 主要是从硬件做什么？软件怎么做？来区分 正如我们刚才所介绍的 中断/异常机制，实际上是现代计算机系统中的核心机制之一 那么它的主要工作，是 硬件和软件相互配合来完成的 通过软硬件的配合，来使计算机的能力 得到充分地发挥 那么在这个机制工作过程中，硬件该做什么事情呢？ 硬件做的工作呢，实际上是捕获 中断源发出的各种中断/异常的请求 以某一种方式呢来响应，通过 把控制权转交给特定的处理程序来完成这个过程 那么这个过程呢，我们把它归结为中断 异常的响应，响应中断，响应异常 这是硬件完成的工作。 软件要做什么事情呢？ 软件做的事情就是，识别中断啊、 异常类型 完成对应的处理，实际上就是 处理程序，我们把它称之为中断/异常处理程序。 所以硬件完成的是 响应，软件完成的是处理 那么关于中断响应 它的主要的工作，就是发现中断 接收中断的一个过程，那么这个过程是由中断的硬件部件完成的 在我们的处理器控制部件当中呢 设置了一个中断寄存器 保存了发来的各种各样的中断信号 那么 CPU 何时来做响应中断的工作呢？ 
我们来通过一个图来 示意，看看 CPU 是如何来响应中断的 CPU 取下一条指令 然后呢执行这条指令 在执行完这条指令之后，也就是，在每条指令周期 的最后，扫描中断寄存器 查看是否有中断发生 是否有中断信号 如果有中断信号，就要对中断进行相应的处理 所以，如果有中断 那么，中断的硬件，会将该中断触发器 把它的内容按规定编码 送到了程序状态字寄存器当中的相应的位 那么这个中断，这几个规定的这个 码子，我们称之为中断码，中断码 所以把中断的信号按照规定编码，形成一个中断码，送到相应的 寄存器的相应位，然后硬件会去查一个表，中断向量表 查中断向量表呢是把中断处理程序把它调出来 啊，调出来。 那么调出来以后 那么下一个周期，实际上就是执行中断处理程序 那么如果没有中断来 当然也可能说我不接收中断，那么就继续执行下一条指令 那么这里头我们看到硬件还要做一件事情，就是查一张表 中断向量表，那么这个中断向量表呢 实际上是个非常重要的软硬件结合的这么一个数据结构 我们来介绍一下什么是中断向量表 中断向量表，每一行呢实际上是一个中断向量 中断向量表是由若干中断向量组成 每一个中断向量其实就是一个内存单元 它是存放了中断处理程序的这个入口地址 以及这个程序，在运行的时候所需要的一个处理机的状态字 若干中断向量构成了中断向量表 那么，操作系统呢要把这张表填写 事先先编好了中断处理程序 把这些中断处理程序的起始地址，或者入口地址，填在中断向量表里头 那么当中断发生的时候呢，那么执行流程就会按照中断的 号儿，或者是异常的类型，不同，通过这张表，通过中断向量表 把控制权转移给对应的中断处理程序 我们来用一个例子 看一看 LINUX 当中，中断向量表 我们得到一些感性认识。 那么这一张中断向量表里 有 0 到 255 个中断向量 其中呢，0 到 19 呢，是用于不可屏蔽中断和异常的 我们再进一步看看 0 到 19 当中，有哪些我们熟悉的 中断或异常，比如说 0 号，中断向量，其实就是除零 异常，1 号中断向量呢是单步调试用的 4 号呢，是用于算术溢出 6 号呢，用于我们所说的一些非法操作数 12 号用于栈的异常 栈出现问题了。 13 号用于保护性错误，保护性异常 而 14 号呢，就用于我们说的缺页异常，页故障 那这些呢，我们都是之前，相对来讲都了解这样一些异常了 我们再看一个我们非常关注的，就是 128 号 中断向量，128 中断向量用于什么呢？大家可以看，用于我们的系统调用 用于，它也是一个异常，它是用于系统调用这样一个可编程的异常 所以通过这张表我们大概对中断向量表的构成有一个感性认识 下面我们通过这张图，来 回顾一下整个中断响应的过程 第一步，设备 发来了中断信号，第二步 中断硬件部件，会去保存现场 把这些内容保存到了系统堆栈里头，保存的内容我们也可以看到 主要的是 PSW 加 PC 的内容 然后，第三步， 中断硬件根据中断码来去查中断向量表 通过查中断向量表得到对应的中断处理程序 第四步 把中断处理程序的入口地址等相关信息 推送到相应的寄存器，那么下一个指令 周期开始，就是执行中断处理程序了 我们从这张图可以看到 一个程序正在执行过程中被打断了，被打断那一点叫做中断的断点 然后转去执行相应的中断处理程序 执行完中断处理程序之后呢，返回到刚才的断点，继续执行 所以整个中断的响应的过程，实际上就是这样一个示意 下面我们来看看软件部分 中断处理程序，在设计操作系统的时候，我们会 为每一类中断或者异常事先都编好相应的处理程序 然后呢，在操作系统初始化的过程中呢，再把它这个中断向量表 设置好，就把这些处理程序的入口地址和 PSW 这些信息设置到 中断向量表里头。 好，当软件设置好了 之后，操作系统初始化以后，也建好了这张表 在运行的过程中，当系统运行时 要响应中断了，那么中断的硬件部件 通过刚才我们描述的步骤，就把 CPU 的控制权，转交给了中断控制程序 那么下面，就是中断处理程序主要做的工作 中断处理程序呢，首先要保存相关寄存器的信息 那么我们要说明一下，在刚才那张图当中 硬件部件会保存关键寄存器的信息 那么其他的一些寄存器的信息呢，还要再做进一步地保存 所以呢，中断处理程序呢，首先要做这样一个事儿 然后就去分析中断的异常的具体原因，究竟是哪一类中断，哪一类异常 比如说，打印机为例，打印机来了中断信号 那么具体的原因是打印机正常地完成了任务？还是 由于没有打印纸了，或者是没有碳粉了，来发出的警告 好，所以这是具体原因。 
根据这个具体原因呢，实际上呢，要 执行对应的处理程序。 啊，执行对应的处理程序。 当然如果有些 中断发生了严重的错误可能就不再返回了，就报错退出了 大部分情况下呢，执行完处理程序之后呢，会恢复现场 返回被事件打断的这个程序。 归纳一下呢 实际上呢我们可以这样来总结 软件提前设置好，硬件部件来执行 所以我们要区分，哪些是软件，就是操作系统事先做好的工作 哪些是硬件，在执行过程中，要做的规定的一些流程 我们为了 加深大家的印象，我们再次以输入输出中断为例 把这个过程再贯穿一次。 比如说 打印机，给CPU发了中断信号 那么CPU处理完当前指令之后呢，就去检测到了这个中断 判断出中断的来源，并向相关的设备发了一个确认信号 那么这部分工作呢，肯定是由硬件来完成的 CPU开始为软件处理中断呢，来做准备工作 比如说要将CPU的状态切换到内核态 并且呢，在 系统堆栈中呢保存非常重要的 寄存器内容，这里头主要指的是程序计数器PC，呃，PS,呃，程序计数器PC 还有这个程序状态字PSW 那么这部分工作呢也是由硬件做的 下面 CPU根据中断码，来查询 中断向量表，获得与这个中断相关的处理程序的入口地址 并且将程序计数器PC设置成该地址 这样新的指令周期开始的时候，CPU的控制权，就交给了这个中断处理程序 那么，这呢，也是由硬件来完成的 做完这个事情之后，那么下一个中断处理程序开始工作了，那么这是由软件来完成的 那么当然了，包括在系统堆栈中保存一些现场信息 或者，如果因为我们是打印机中断，对吧，打印机 完成了，那么我们来检查一下I/O设备的状态 操纵I/O设备，或者是在设备和内存之间呢来传送数据 啊，做这样一些比较具体的工作。 当中断处理 结束了以后，那么CPU去执行的是中断返回指令 那么从系统栈中恢复 被中断程序的上下文环境，就是几次压栈的那种，把它恢复 那么CPU的状态呢，也是恢复成原来的状态，也要如果是从用户态进到核心态呢 那么就把它设置成用户态 而PSW和PC的值呢，也恢复成以前断点的值 在一个新的指令周期开始呢，就继续执行被打断的那个程序 那这一部分工作呢，实际上也可以说是由硬件来完成的 所以在这一部分里头呢，我们要搞清楚 在中断响应，中断处理的过程当中 哪些是硬件做的，哪些是软件做的 那么软件呢 做的什么事情呢，我们可以用一个例子，啊，举个例子，来说明一下 中断处理程序都做哪些工作？比如说还是以 打印机为例，这是一个典型的I/O的中断处理程序 那么，通常呢，我们会做两类处理 一类呢，是I/O操作正常结束 正常结束呢，那你要做的事情就是说，如果 有程序正在等待这次I/O的结果 那么就把它唤醒，让它继续 做要做的工作。 
如果 有新的I/O操作在等待，要继续新的 I/O操作，那么你就准备好数据，重新启动I/O 就是这样一个正常结束。 如果出现了错误，在I/O过程中出现了错误 那么，首先需要的是重复执行一下刚才失败的这种I/O操作 看看是不是偶然发生了错误，所以是要重新执行 但是这个重新执行呢是有上限的 比如说我重新执行两次或者三次 达到了上限之后呢，系统呢就是报错了，啊报错说出现故障了 那么通常呢，我们在比如读盘的时候，比如特别是 典型的我们看读光盘的时候，啊，读这个DVD的时候 如果DVD没读出来，那么会反复地读很多次， 我们会感觉到时间很长，这样的话呢说明什么呢，它正在重复在执行 这就是软件一个典型的这个软件做的工作。 

4. 实例：X86的中断与异常机制

下面我们介绍中断异常机制的实例。 那么主要以 X86 处理器对中断／异常的这个支持为例。 在 X86 处理器当中 中断是指的由硬件信号引发的， 那么通常分成了可屏蔽中断和不可屏蔽中断。 异常呢是由正在执行指令而引发的， 前面我们说的像除零啊、 算数溢出等等。 那么 X86 这样一个处理器呢，大约呢发布了大概 20 多种 不同的异常。 不同的处理器发布的异常个数是不一样的。 而且对于某些异常呢，CPU 会在处理异常处理 程序之前产生一个硬件出错码， 把这个硬件出错码压入到内核栈里头。 
另外一种就是特殊的一种异常，叫系统调用。 这个我们前面反复强调，它是用户态到内核态的一个唯一入口。 在 X86 处理器当中呢我们有中断控制器。 中断控制器呢是负责将硬件的中断信号转换为中断向量，并引发 CPU 的中断。 那么这里头我们来介绍中断向量表。 在 X86 处理器当中呢我们有实模式和保护模式之分。 在实模式下呢，中断向量表就叫中断向量表，存放了中断服务程序的入口地址。 
那么拿到这个地址之后呢，把这个段地址，这个 入口地址等于这个段地址，段寄存器的段地址， 左移 4 位，然后加上偏移地址就得到了这个中断处理程序的入口地址。 由于在实模式下呢没有 CPU 状态的这种转换， 所以中断的处理与一般过程的这个调用呢是很相似的。 但是我们现在更多地呢是在保护模式下工作。 因此呢在保护模式下呢，中断向量表呢就改了个名字，叫中断描述符表。 那么中断描述符表当中每一个中断向量呢 我们把它现在的名字呢就叫门描述符，用一个门描述符 来表示我们前面说的中断向量，这是一个数据结构。 好下面我们来看一下具体的。 那么中断向量表或者叫中断描述符表 这里头有几种类型的门描述符呢？一般情况下有四种。 
任务门、 中断门、 陷阱门还有调用门。 那么我们呢通常只用了两种，一个是 中断门，一个是陷阱门。 所谓中断门呢是在这个门描述符当中给出了段选择符， 以及中断／异常程序的一个段内的偏移量。 中断门通过之后， 系统会自动禁止中断，就不再接收新的中断了。 而陷阱门呢其实它的 整体的处理是和中断门相似的，只是通过了陷阱门之后 不会自动禁止中断，所以还可以接收新的中断。 我们来看看门描述符的 一些具体的数据结构和整个的中断响应过程。 这里头呢我们来首先看一下 这张表，中断描述符表。 
有一个寄存器叫 IDTR 寄存器， 那么通过这个寄存器我可以得到中断描述符表的 地址，我可以找到中断描述符表。 中断描述符表的每一行是个门描述符，或者叫做中断描述符。 那么中断描述符的格式呢是这样一个格式： 它呢是 64 位，分成不同的内容。 我们现在看到这有一个门的类型，是中断门还是陷阱门。 还有一个呢是一个特权级 DPL，这就是我们说的那种 特权级别，描述了特权级别。 通过这个中断描述符呢 我们得到了一个段选择符。 段选择符的格式呢我们来看一下，段选择符其实就是个索引， 它有一个索引，当然了它还有一个在哪个表索引，是 GDT 表还是 LDT 表？那么还有一个特权级，所以 段选择符也有特权级。 
有了这个索引之后呢，我们用它来什么呢？查 这张表。 这张表叫做全局描述符表。 我们就中断处理程序的相关信息放在这张表的某一行。 那么查到这张表之后呢， 我们就得到了一个另外一个 描述符，我们叫做段描述符。 这个段描述符当中也有，大家可以看也有这个 相应的权限，相应的权限，在这个 属性里头也有相应的权限。 我们看到每一个段都有相应的权限，表明它的 特权级别。 
但是在段描述符当中我们主要关注的呢是段的基地址。 有了这个段的基地址，有了在中断描述符当中的 偏移，我们就得到了 中断服务程序的一个入口地址。 所以中断服务程序的入口地址呢是 段基址再加上偏移。 那么段基址呢 是通过查 GDT 表得到的。 怎么查 GDT 表呢？是通过了段选择符做索引去查的。 是这样一个大致的过程。 
我们把刚才那个过程呢 再用文字介绍一下。 首先，我们要确定 与中断和异常相关的中断向量， 某一个中断向量。 然后呢 去查中断描述符表，中断描述符表的 起始位置呢可以通过一个 IDTR 寄存器得到， 得到了这个中断描述符呢是在这个表当中的第 i 项，第 i 项。 然后我们再去查 GDT 表，首先先从 GDTR 寄存器得到了 GDT 的地址， 结合中断描述符表当中的 中断描述符当中的段选择符， 在 GDT 表当中呢查到对应的 段描述符。 从这个段描述符当中呢得到了我们中断 或者异常处理程序的段的基地址。 这个过程当中呢其实是要做很多的特权级检查。 刚才我们看到了不同的描述符里头都有特权级，所以要做相应的特权级检查。 
下面要检查是否发生了特权级的变化。 如果是有特权级的改变，则要进行堆栈的切换。 因为我们要用的堆栈必须是与新的特权级相关的堆栈。 比如说你从用户态进到了内核态， 原来的堆栈指针指向的是用户态，用户栈， 现在我要把堆栈的指针指向内核栈， 然后才能够做下面的工作。 那么下面的工作呢实际上就是硬件先压栈， 把一些信息保存在堆栈里头。 如果 异常产生了，刚才讲的异常产生了一些出错码，也要把这个出错码 把它保存在堆栈中，当然这是某些异常会有这个出错码。 我们如果是中断门进来的，那么就要把 IF 位清掉，那么禁止中断，禁止下面的中断了。 
当然如果是陷阱门进来就不需要做这件事。 那么通过中断描述符当中的段内偏移量 还有段描述符当中的基地址，我们就可以 算出来中断／异常处理程序的一个入口地址，然后呢去执行 它的第一条指令。 再用这张图 把刚才的过程走一遍。 得到了中断描述符， 通过中断描述符当中的段选择址 和 GDTR 当中的地址去查 GDT 表， 得到了段的描述符。 段的描述符当中我们就得到了段的基地址， 再从中断描述符当中得到的偏移量 相结合，就得到了中断处理程序的入口地址。 这就是在内存中的中断处理程序。 


5. 系统调用机制

下面呢，我们来介绍系统调用机制 那么这是操作系统向用户程序提供的接口 什么是系统调用？ 系统调用有什么作用？有哪些典型的系统调用呢？ 我们来看一下。 系统调用呢 是用户在编程时可以调用的操作系统功能 系统调用是一个简称 它的全称应该是操作系统功能调用，简称系统调用 那么有了系统调用 操作系统就可以给编程人员，提供了一个提出服务请求的这么一个接口 通过这样一个系统调用 使得 CPU 的状态从用户态陷入了内核态 前面我们已经介绍过了，当用户要做一些事情，而这些事情呢 是需要用特权指令来完成的。 因此用户不能直接执行特权指令 所以就通过了一个接口向操作系统提出请求 由操作系统来完成这个过程。 那么就需要这个接口，通过这个接口 从用户态陷入内核态 这就是操作系统当中系统调用 所起的作用。 
当然了有很多的系统调用 每个操作系统呢都提供了几百种系统调用 那么我们来简，简单来看一下啊，进程控制类 比如说创建进程啊，撤销进程 进程的通信类，那么可以一个进程给另外一个进程发消息 还有文件使用的类。 比如说创建 撤销、 打开、 关闭、 读、 写文件 还有对目录的操作、 对设备的管理 以及一些信息维护，那么这些呢都是 典型的系统调用的例子。 那这里呢也给大家提一个小小的问题 那么 Linux 操作系统当中，提供了多少个系统调用呢？ 大家不妨呢，根据不同的版本去查一下，看看某个版本提供了多少个系统调用 那这里的我们要区分系统调用 库函数、 API、 内核函数这样几个不同的概念 那么系统调用和我们说的 C 库函数 或者是 API 函数有什么关系呢？那么系统调用和内核函数又有什么关系呢？ 我们来看这张图。 那么应用程序 可以直接调系统调用 但是呢通常情况下，应用程序都是 通过了 C 函数库或者是 API 的接口来间接地调用系统调用 那么在操作系统内核当中，提供了很多的内核函数 那么这些内核函数呢，经过了封装，经过了封装 实际上呢把它提供到了 C 函数库，或者是 API 接口 所以系统调用呢 对内，对于内核而言，那么内核函数就是这个系统调用的处理程序，处理程序 而这些处理程序呢通过封装 在 C 函数库或者 API 接口呢提供给用户来使用 但是呢，C 函数库里头或者是 API 接口里头还有一些函数 它们呢不是系统调用，它们就是一些普通的函数在完成一些功能 而且一些函数 通过系统调用对应到了多个内核函数 当然也可能是某一个函数 通过系统调用呢对应内核的一个函数 这样呢都是不太一样的。 
内核函数当中 也有一些函数呢是不开放给用户使用的 那么这就是系统调用库函数、 API 和内核函数的一个 简单的区别。 那么应用程序往往，大部分情况下是通过调用函数 调用函数。 那么这个函数执行过程中呢再去 变成系统调用来进入内核来完成，基本上是这样一个情况 那么下面我们来设计一下系统调用机制 来看一下执行系统调用的过程是什么样的 那么我们要设计 系统调用，首先 我们要利用硬件给我们提供的支持 就是中断异常机制 通过这个机制可以支持系统调用服务的一个实现。 所以我们要利用硬件的这个机制 那么然后呢，我们要选择一条特殊的指令 那么指令用作我们的陷入指令，也称之为访管指令 那么这条指令呢作用呢，是通过这条指令的执行呢引发一个异常 完成从用户态到内核态的切换工作 那我们看到只有一条指令 也就是说所有的系统调用，都是通过这条指令来进入内核的 在中断向量表或中断描述符表当中 有一行专门用于系统调用 那么在初始化，在操作系统初始化的时候，要把这，这个 表的这一项设置好。 然后呢操作系统呢要为 每一个系统调用事先先给它一个编号，确定一个 编号，有的时候呢叫系统调用号，有的时候呢叫功能号 那么为什么要有编号呢？因为我们刚才说的所有的 系统调用都通过这一条指令进来 那么到底哪一个系统调用呢？我们要通过编号来区分 那么每个系统调用其实还有不同的参数 有的系统有参数，有的系统调用没有参数，所以呢我们还要设计相应的参数 那么这些工作除了操作系统的设计之外 还需要编译器来帮忙，那么编译器呢 会把这个封装的系统调用把它展开 展开的话呢，在过程中呢生成这条特殊的 陷入指令，以及这些参数的 推送寄存器的这些指令，要生成这些 这是编译器要在这过程当中，也要参与进来 那么每一个系统调用 其实都有一段内核函数，或者是一段代码来对应 那么怎么样找到对应的这个内核函数呢？我们就需要设计一张系统调用表 这张表就把系统调用的各项服务的入口地址 填在这张表里头，那这张表也是在这个初始化的时候 设置好了。 
所以在设计一个系统调用的时候呢，我们要有这样一些要素 那么这个过程中呢，我们还有一件事情要说明一下 就是参数传递的这个问题，那么 用户程序在执行的时候呢，是用户栈。 那我们知道 一般的函数调用呢是通过这个栈来传递参数的 但是现在我们的面临的问题呢是用户和系统 那么用户程序不能够把它的这些参数呢，推到系统栈里头去，这是不允许的 所以我们现在要解决的问题呢，就是怎么样来实现用户 程序把它的参数，调用函数的参数传递给内核 通常呢有三种方法，可以由陷入指令自带参数 也可以通过通用寄存器来传递参数，因为这些通用寄存器是 操作系统和用户都能访问的 那么也还可以在内存中开辟一个专门的 专用的区域来传递参数。 通常呢， 大部分情况下，我们会采用第二种方案 通过通用寄存器来传递参数 但是由于寄存器的个数有限 会限制传递参数的数量 我们举一个 例子来说明系统调用的这样一个过程 那么高级语言编写程序通过了编译之后呢，比如说变成了汇编 语言，好，我们在高级语言当中调用了一个库函数 write 它和系统调重名，经常是封装成重名的。 那么，经过编译之后呢，实际上是要编译成这样一个汇编指令。 那么要把 write 的这个函数对应的系统调用号，推到寄存 器里头，要在这里安排一条特殊的陷入指令。 好，那么我们进一步来讨论这个例子。 这是 C 代码，我们从高级语言 的角度来看这段代码，调用了一个函数 write。 
write 有三个参数：第一个参数是 1 ，表示的是要把结果送到标准输出设备上； 然后，送的内容是放在了字符串里头。 长度是 7，就是 write 这个函数表达了这样一层含义，有三个参数。 还有一个 return 也是一个 函数，它也是一个系统调用，啊。 那么我们来看一下， 这段 C 代码，编译成了汇编指令之后是个什么样子的。 我们首先要说明一下，那么上述的代码，刚才的 C 代码 把它编译之后，变成了汇编的代码， 现在的系、 当前的系统当中，真实的这个编译器 编译的结果和我们这个显示的内容呢，有点不太一样。 主要的原因是，在这个过程当中 C 做了很多层的封装， 啊，所以这样的话呢，结果可能不太一样。 但是呢，这一部分， 和系统调用相关的这一部分， 和我们上、 上面的那个 C 代码的那个相关的调用呢， 是比较一致的，我们只是一个示意啊。 
不是、 不完全是一个真实的编译后的内容，但是 主要的这个步骤是一样的，我们来看一下这几个步骤： 那么这几个步骤实际上呢，就是把一些数据推送到寄存器里头。 那么这些数据包括什么呢？首先，先包括了系统 调用的编号，而系统调用编号，我们 write 这个系统调用编号是 4， 所以就把 4 推送到了 eax 寄存器， 这个是规定的，eax 寄存器存放了系统调用的编号。 剩下的 write 的三个参数呢，依次送到不同的寄存器。 然后在这里安排了一条特殊的指令，就是我们说的那个陷入指令。 通过这个陷入指令呢，在执行这段代码的时候呢，会引发一次系统调用。 我们刚才看到，在刚才那段代码当中，还有一个系统调用，我们再来看一下，啊。 
那这个系统调用，它的作用是什么呢？它的作用是返回、 退出。 那么退出的系统调用编号呢是 1 号，1 号系统调用。 那么它的参数呢是 0，返回 0，然后 也安排了一个特殊的陷入指令，所以， 只要是系统调用，都是这样一个基本的过程。 好，那么，我们知道了 有这么一条特殊的指令，当执行这条指令的时候，会引发一个系统调用。 那么系统调用的执行过程呢，我们来看一下。 当 CPU 执行到了特殊的 陷入指令的时候，那么各个部件、 硬件 部件和软件就开始工作了，首先呢是 硬件的中断／异常机制工作，它的工作呢， 保存现场；查找中断向量表， 并且把 CPU 的控制权转交给 中断处理程序，而这个中断处理程序，因为我们是 系统调用就是叫做系统调用的一个总入口程序。 
因为我们知道所有的系统调用，都是通过这个中断向量进来， 都是执行这个总的入口程序，总控程序，可以看成是。 然后下面，就是这个系统调用的总控程序执行了， 它呢，也要保存现场，然后呢，把参数 保存在内核的堆栈当中，下面呢它要去查找另外一张表 系统调用表，把控制权交给 对应的内核函数，或者是系统调用的处理程序。 所以要查这张表。 接着就去执行系统调用的过程， 然后呢，再恢复现场，返回用户程序。 那这里头我们可以看到，其实有一个表是中断向量表，这是硬件来访问的，然后 主要的作用是找到系统调用的总控程序。 还有一张表呢，是系统调用表。 那么这是总控程序里查这张表，根据 功能号，根据系统调用编号，来把 CPU 控制权转交给对应的内核函数或者是系统调用处理程序。 

6.实例：基于X86的Linux系统调用机制简介

下面我们再以 Linux 为例，看一看基于 x86 处理器的 Linux 的系统调用是怎么实现的 当然这部分内容呢是希望通过这个例子 加深对系统调用整个过程的一个理解，包括怎么去设计，包括它的执行过程 并不要求大家全搞得非常清楚，因为很多细节我们没有介绍 好我们来看一下 基于 x86 处理器的 Linux 的系统调用的实现 那么当然了，首先我们要选择一条陷入指令 那么在这里呢， Linux 选择了 128 号中断向量，那么这是十进制 那么十六进制表示呢，就是 80 口，是 int $0x80，是这个我们特殊的这个陷入指令 当然除了这个以外，那么 Linux 还利用了 sysenter sysexit 这一套指令，当然我们这里头介绍其中一种方法 那么中断向量表中的门描述符 它是怎么样来初始化的呢？我们来看一下，在系统初始化的时候呢 对于中断描述符表当中的 128 号这个门描述符呢，我们要对它进行初始化 首先呢，先把这个门描述符的 从右边数的 2、 3 两个字节设置成段选择符 然后 0、 1、 6、 7 这 4 个字节设置成了一个偏移量 那么通过这个段选择符和这个偏移量 能够最终使得硬件找到 中断处理程序也就是 system_call() 这个处理程序 那么这一段的设置，如果大家去读代码的话呢，可以在 这条语句当中看到，set_system_gate 80 口指向 system 口，是通过这个 做好设置。 那么在中断描述符当中，门描述符当中呢门的类型是采用什么类型呢？ 那么它的类型采用的是 15，15 类型呢实际上是陷阱门，那么为什么用陷阱门呢？ 是因为在执行系统调用过程中，我们还允许接收中断的话 那我们就用陷阱门进来，就不自动关闭中断了。 那么 特权级设置成多少为好呢？合适呢？ 
我们看到，特权级设置为 3 设置为 3。 因为我们知道，在用户态进入到内核态的时候要经过这个门 那么用户态的特权级是 3，R3，对吧，是 3。 那么 在经过这个门的时候，要求当前运行程序 的这个特权级要等于或者高于什么呀？ 要执行的这个代码段。 你要执行的中断处理程序如果它的特权级 不是 3，那么那就是 0，那么 3 比 0 的 级别要低，注意这个数字啊，这 3 比 0 的级别要低，它就进不来了。 所以要保证 用户态能进到核心态，所以这个门描述符一定要是什么呀？是 3，与用户态的 这个特权级是一致的，相同的 这样就允许用户可以通过这个门描述符 那么我们来看看在 Linux 当中到底有哪些 系统调用和它的编号呢？这里没列举所有的，列举了几个，我们大致有个印象 比如说 exit ，这个系统调用实际上就是 1 号系统调用 fork 创建进程是 2 号系统调用 read、 write 是 3 号、 4 号系统调用 我们可以看到不同的系统调用都有一个编号，有个感性的认识 好，那么下面，当系统执行过程中 执行到了 int $0x80 这个指令以后 要做哪些事情呢？我们来看一下。 
那么由于特权级发生了改变 所以这时候要切换栈，要不从用户 栈切换到内核栈，怎么切换栈呢？是 CPU 从任务状态段 TSS 表当中 装入新的栈指针，指向内核栈 那么内核栈有了以后，剩下 就是压栈，把一些信息往栈里压。 那么是由硬件 自动依次地把用户栈的信息 SS：ESP 标志状态字，呃，标志寄存器的信息 EFLAGS 还有返回的地址用户态的 CS 和 EIP 寄存器的内容 依次压栈，依次压栈。 压完栈 之后，特别是把 EFLAGS 压完栈之后，就复位 TF 位 然后呢，IF 位保持不变，保持不变。 下面 硬件用 128 在 中断描述符表当中找到了刚才我们初始化好的门描述符 从当中呢取到了段选择符，装到了代码段寄存器 CS 当中 而代码段描述符当中的基地址 和陷阱门描述符当中的偏移，由这两部分就能够 定位我们系统调用的一个总的入口 地址，总的入口地址。 当然这个过程中有一些硬件的工作 我们之前介绍过了，这里就简单地说一下 我们再 复习一下刚才的过程。 那我们来看这张图 左边是应用程序，那么应用程序调了个库函数 write 所以应用程序在用户态下调用了一个 C 库的库函数，这里比如说是 write 那么封装后的这个 write ，就在库里封装后的 write 它主要做好的是什么呀？参数的传递工作，然后呢，设置了一个 int $0x80 这条指令，用它呢来产生一次异常。 
所以我们看 封装例程当中就变成了若干条参数 推送到寄存器的指令以及 一个 int $0x80 作为陷入的这么一个特殊的指令 好，当执行这条指令的时候呢，我们知道就陷入了内核态，就是陷入后的工作 那么 CPU 执行到 0x80，那么它通过 0x80 号在 IDT 表中，中断描述符表当中找到了对应的服务例程 system_call()，这个是总的，系统调用的总的入口地址，并且调用它 调用它之后我们可以看到，之前啊，在 调用它之前其实已经做好了一些压栈的工作，按照我们刚才叙述，把一些 重要的寄存器、 这个用户栈的信息、 EFLAGS 信息和返回地址都压好栈了 那么陷入之后的这个 system_call() 主控程序还要把 eax 再压栈 再把剩余的其它的寄存器的内容呢 压栈，那么叫 SAVE_ALL ，SAVE_ALL ，把它全都压在堆栈里头 压完栈之后再去调用查这个 系统调用表去调用对应的那个内核函数 内核函数，这个内核函数比如说 sys_wirte() 对应的内核函数 所以我们看看就是 system_call() 是将参数 存在内核栈，然后再根据系统编，这个编号 调用编号再去查系统调用表，找到 这个系统调用内核函数的入口，入口 再执行这个函数。 执行完了之后，那么 通过执行这个 ret_from_system_call() 就是返回 用户程序，从这返回，返回到用户程序 这就是一个 Linux 的系统调用的一个执行过程 那这里头简单地啊给大家看一下，这个 SAVE_ALL SAVE_ALL 的一段代码。 那么 SAVE_ALL 呢是把其他的一些剩余的寄存器内容压栈 那么这个栈，压完栈之后，栈的状态，栈的这个布局就是这样的 那么前面的信息，栈前面的信息 是硬件压的，然后系统调用号是 这个 system_call() 这个程序推送的，剩下的 从 es 开始，这些呢是 SAVE_ALL 完成的，那么完成之后 就把这个栈增长了，压栈的顺序是这样一个顺序 这是一个小例子，大家看懂这个就可以了 好，那么我们在讲完了这个中断 异常机制还有这个系统调用之后呢，我们再来 归纳一下，在中断发生之后 那么操作系统底层的一些工作的一些主要步骤 那么这张，我们要介绍的内容呢是在教材的 52 页的这个图 2-5。 第一步 硬件压栈主要的内容是程序计数器 PSW 等 硬件从中断向量装入新的程序计数器 汇编语言过程来保存一些寄存器的值 汇编语言过程呢设置新的堆栈 那么 C 语言 中断服务程序呢来运行，可能是读 读文件啊，或者是读盘啊，缓冲输入等等 进程调度程序决定下一个 将要运行的进程，也就是说这件事情完了之后呢，转向进程调度程序转 由它来决定下一个要运行的程序 C 语言过程呢，通过 C 语言过程呢返回到汇编代码 然后汇编代码呢，汇编代码的一个过程呢来开始新的 运行新的这个进程。 那么这个过程当中呢其实我们主要要强调 是谁来完成什么样的事。 也就是说前两步是硬件做的工作 后面呢是软件做的事情，但是软件做的事情 呢，我们来看有些呢是必须用汇编语言来完成 有些呢，是可以用 C 语言来完成 那是，因为跟体系结构相关的就要用汇编语言 那么进程调度程序中间还要发挥它的作用 所以从这样一个例子当中呢，我们既 把刚才的过程又重复了一遍，更多的呢我们是通过这个里头看到了这个过程当中 哪些是硬件，哪些是软件，哪些是汇编语言，哪些是高级语言完成 那么本讲的内容呢其实就讲了三件事 第一件事呢，就讲了 CPU 的状态，这是计算机系统的一种保护机制 第二件事情呢，讲了中断/异常机制 这是硬件的一个机制。 第三个呢，是讲了系统 调用机制，是利用了硬件机制完成一个向 用户提供服务的这么一个接口 回去之后呢希望大家呢能够去阅读相关的教材 1.3、 1.6，那么还有呢第 2 章的第 52 页的这张图，以及说明该图思路的一些段落 本章的重点概念呢有以下一些： CPU 的状态 内核态/用户态，特权指令/非特权指令 中断，异常，中断响应，中断向量 中断处理程序，系统调用，陷入指令 系统调用号和系统调用表。 
希望大家把这些重要的概念掌握了 那么今天的课程就讲到这里，谢谢大家 